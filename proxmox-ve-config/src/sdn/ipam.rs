use std::{
    collections::{BTreeMap, HashMap},
    error::Error,
    fmt::Display,
    net::IpAddr,
};

use serde::Deserialize;

use proxmox_network_types::ip_address::Cidr;
use proxmox_network_types::mac_address::MacAddress;

use crate::{
    common::Allowlist,
    firewall::types::{ipset::IpsetScope, Ipset},
    guest::types::Vmid,
    sdn::{SdnNameError, SubnetName, ZoneName},
};

/// Struct for deserializing a gateway entry in PVE IPAM.
///
/// They are automatically generated by the PVE SDN module when creating a new subnet.
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct IpamJsonDataGateway {
    #[serde(rename = "gateway")]
    _gateway: u8,
}

/// Struct for deserializing a guest entry in PVE IPAM.
///
/// They are automatically created when adding a guest to a VNet that has a Subnet with DHCP
/// configured.
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct IpamJsonDataVm {
    vmid: Vmid,
    hostname: Option<String>,
    mac: MacAddress,
}

/// Struct for deserializing a custom entry in PVE IPAM.
///
/// Custom entries are created manually by the user via the Web UI / API.
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct IpamJsonDataCustom {
    mac: MacAddress,
}

/// Enum representing the different kinds of entries that can be located in PVE IPAM.
///
/// For more information about the members see the documentation of the respective structs in the
/// enum.
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Hash, PartialOrd, Ord)]
#[serde(untagged)]
pub enum IpamJsonData {
    Vm(IpamJsonDataVm),
    Gateway(IpamJsonDataGateway),
    Custom(IpamJsonDataCustom),
}

/// Struct for deserializing IPs from the PVE IPAM.
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct IpJson {
    ips: BTreeMap<IpAddr, IpamJsonData>,
}

/// Struct for deserializing subnets from the PVE IPAM.
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct SubnetJson {
    subnets: BTreeMap<Cidr, IpJson>,
}

/// Struct for deserializing the PVE IPAM.
///
/// It is usually located in `/etc/pve/priv/ipam.db`
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct IpamJson {
    zones: BTreeMap<ZoneName, SubnetJson>,
}

/// Holds the data for the IPAM entry of a VM.
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct IpamDataVm {
    ip: IpAddr,
    vmid: Vmid,
    mac: MacAddress,
    hostname: Option<String>,
}

impl IpamDataVm {
    pub fn new(
        ip: impl Into<IpAddr>,
        vmid: impl Into<Vmid>,
        mac: MacAddress,
        hostname: impl Into<Option<String>>,
    ) -> Self {
        Self {
            ip: ip.into(),
            vmid: vmid.into(),
            mac,
            hostname: hostname.into(),
        }
    }

    pub fn from_json_data(ip: IpAddr, data: IpamJsonDataVm) -> Self {
        Self::new(ip, data.vmid, data.mac, data.hostname)
    }

    pub fn ip(&self) -> &IpAddr {
        &self.ip
    }

    pub fn vmid(&self) -> Vmid {
        self.vmid
    }

    pub fn mac(&self) -> &MacAddress {
        &self.mac
    }

    pub fn hostname(&self) -> Option<&str> {
        self.hostname.as_deref()
    }
}

/// Holds the data for the IPAM entry of a Gateway.
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct IpamDataGateway {
    ip: IpAddr,
}

impl IpamDataGateway {
    pub fn new(ip: IpAddr) -> Self {
        Self { ip }
    }

    fn from_json_data(ip: IpAddr, _json_data: IpamJsonDataGateway) -> Self {
        Self::new(ip)
    }

    pub fn ip(&self) -> &IpAddr {
        &self.ip
    }
}

/// Holds the data for a custom IPAM entry.
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct IpamDataCustom {
    ip: IpAddr,
    mac: MacAddress,
}

impl IpamDataCustom {
    pub fn new(ip: IpAddr, mac: MacAddress) -> Self {
        Self { ip, mac }
    }

    fn from_json_data(ip: IpAddr, json_data: IpamJsonDataCustom) -> Self {
        Self::new(ip, json_data.mac)
    }

    pub fn ip(&self) -> &IpAddr {
        &self.ip
    }

    pub fn mac(&self) -> &MacAddress {
        &self.mac
    }
}

#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub enum IpamData {
    Vm(IpamDataVm),
    Gateway(IpamDataGateway),
    Custom(IpamDataCustom),
}

impl IpamData {
    pub fn from_json_data(ip: IpAddr, json_data: IpamJsonData) -> Self {
        match json_data {
            IpamJsonData::Vm(json_data) => IpamDataVm::from_json_data(ip, json_data).into(),
            IpamJsonData::Gateway(json_data) => {
                IpamDataGateway::from_json_data(ip, json_data).into()
            }
            IpamJsonData::Custom(json_data) => IpamDataCustom::from_json_data(ip, json_data).into(),
        }
    }

    pub fn ip_address(&self) -> &IpAddr {
        match &self {
            IpamData::Vm(data) => data.ip(),
            IpamData::Gateway(data) => data.ip(),
            IpamData::Custom(data) => data.ip(),
        }
    }
}

impl From<IpamDataVm> for IpamData {
    fn from(value: IpamDataVm) -> Self {
        IpamData::Vm(value)
    }
}

impl From<IpamDataGateway> for IpamData {
    fn from(value: IpamDataGateway) -> Self {
        IpamData::Gateway(value)
    }
}

impl From<IpamDataCustom> for IpamData {
    fn from(value: IpamDataCustom) -> Self {
        IpamData::Custom(value)
    }
}

#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub enum IpamError {
    NameError(SdnNameError),
    InvalidIpAddress,
    DuplicateIpAddress,
    IpAddressOutOfBounds,
}

impl Error for IpamError {}

impl Display for IpamError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str("")
    }
}

/// represents an entry in the PVE IPAM database
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct IpamEntry {
    subnet: SubnetName,
    data: IpamData,
}

impl IpamEntry {
    /// Creates a new PVE IPAM entry.
    ///
    /// # Errors
    ///
    /// This function will return an error if the IP address of the entry does not match the CIDR
    /// of the subnet.
    pub fn new(subnet: SubnetName, data: IpamData) -> Result<Self, IpamError> {
        if !subnet.cidr().contains_address(data.ip_address()) {
            return Err(IpamError::IpAddressOutOfBounds);
        }

        Ok(IpamEntry { subnet, data })
    }

    pub fn subnet(&self) -> &SubnetName {
        &self.subnet
    }

    pub fn data(&self) -> &IpamData {
        &self.data
    }

    pub fn ip_address(&self) -> &IpAddr {
        self.data.ip_address()
    }
}

/// Common representation of IPAM data used in SDN.
///
/// This should be instantiated by reading from one of the concrete IPAM implementations and then
/// converting into this common struct.
///
/// # Invariants
/// * No IP address in a Subnet is allocated twice
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct Ipam {
    entries: BTreeMap<SubnetName, Vec<IpamEntry>>,
}

impl Ipam {
    pub fn new() -> Self {
        Self::default()
    }

    pub fn from_entries(entries: impl IntoIterator<Item = IpamEntry>) -> Result<Self, IpamError> {
        let mut ipam = Self::new();

        for entry in entries {
            ipam.add_entry(entry)?;
        }

        Ok(ipam)
    }

    /// Adds a new [`IpamEntry`] to the database.
    ///
    /// # Errors
    ///
    /// This function will return an error if the IP is already allocated by another guest.
    pub fn add_entry(&mut self, entry: IpamEntry) -> Result<(), IpamError> {
        if let Some(entries) = self.entries.get_mut(entry.subnet()) {
            for ipam_entry in &*entries {
                if ipam_entry.ip_address() == entry.ip_address() {
                    return Err(IpamError::DuplicateIpAddress);
                }
            }

            entries.push(entry);
        } else {
            self.entries
                .insert(entry.subnet().clone(), [entry].to_vec());
        }

        Ok(())
    }
}

impl Ipam {
    /// Generates an [`Ipset`] for all guests with at least one entry in the IPAM.
    ///
    /// # Arguments
    /// * `filter` - A [`Allowlist<Vmid>`] for which IPsets should get returned
    ///
    /// It contains all IPs in all VNets, that a guest has stored in IPAM.
    /// Ipset name is of the form `guest-ipam-<vmid>`
    pub fn ipsets(&self, filter: Option<&Allowlist<Vmid>>) -> impl Iterator<Item = Ipset> + '_ {
        self.entries
            .iter()
            .flat_map(|(_, entries)| entries.iter())
            .filter_map(|entry| {
                if let IpamData::Vm(data) = &entry.data() {
                    if filter.is_none_or(|list| list.is_allowed(&data.vmid)) {
                        return Some(data);
                    }
                }

                None
            })
            .fold(HashMap::<Vmid, Ipset>::new(), |mut acc, entry| {
                acc.entry(entry.vmid)
                    .or_insert_with(|| {
                        Ipset::from_parts(IpsetScope::Sdn, format!("guest-ipam-{}", entry.vmid))
                    })
                    .push(Cidr::from(entry.ip).into());

                acc
            })
            .into_values()
    }
}

impl TryFrom<IpamJson> for Ipam {
    type Error = IpamError;

    fn try_from(value: IpamJson) -> Result<Self, Self::Error> {
        let mut ipam = Ipam::default();

        for (zone_name, subnet_json) in value.zones {
            for (cidr, ip_json) in subnet_json.subnets {
                for (ip, json_data) in ip_json.ips {
                    let data = IpamData::from_json_data(ip, json_data);
                    let subnet = SubnetName::new(zone_name.clone(), cidr);
                    ipam.add_entry(IpamEntry::new(subnet, data)?)?;
                }
            }
        }

        Ok(ipam)
    }
}
